<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      TCP协议简单介绍 &middot; Gerald
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">Gerald</h2>
        </a>
        <ul>
          <li><a href="/about">About</a></li>
          <li><a href="/">Posts</a></li>
        </ul>
    </div>
  </nav>

    <main>
      <link rel="stylesheet" href="/assets/css/syntax.css">
<div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Gerald
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2017-03-01 00:00:00 +0800">March 01, 2017</time>
    
  </div>

  <h1 class="post-title">TCP协议简单介绍</h1>
  <div class="post-line"></div>

  <h4 id="tcp首部">TCP首部</h4>

<p>TCP协议位于传输层，是一种面向连接的、可靠的、基于字节流的通信协议。TCP首部的很多字段都是为了实现这2大特性而设计的。 在一个TCP连接中，仅有两方能进行彼此通信。如果不计任选字段，TCP的首部通常是20字段。</p>

<p><img src="/assets/CFC6314E4B2FD039C450821D946E93E2.png" alt="" /></p>

<p>TCP 的首部包括以下内容：</p>

<!--more-->

<ul>
  <li><strong>源端口和目的端口</strong>（4字节）</li>
</ul>

<p>每个TCP段都包含源端口和目的端口，用于寻找发端和收端应用进程。这2个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。</p>

<ul>
  <li><strong>序号</strong>（4字节）</li>
</ul>

<p>TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。序号字段值指的是本报文段所发送的数据的第一个字节的序号。</p>

<ul>
  <li><strong>确认号</strong> （4字节）</li>
</ul>

<p>表示期望收到的下一个报文段的序号的值。在TCP连接中接收方在收到一个报文后需要返回对应的<strong>确认报文</strong>来确认收到<strong>。</strong></p>

<ul>
  <li><strong>数据偏移</strong> （0.5字节）</li>
</ul>

<p>这个字段实际上是指出了<strong>TCP 报文段的首部长度</strong>，它指出了TCP报文段的数据起始处距离TCP报文的起始处有多远。</p>

<ul>
  <li><strong>保留</strong> （0.75字节）</li>
</ul>

<p>保留为今后使用，目前应置0。</p>

<ul>
  <li>
    <p><strong>标志位</strong> （共六个，0.75字节）</p>
  </li>
  <li>URG 紧急指针有效，与首部中的紧急指针字段配合使用。</li>
  <li>ACK 确认序号有效，一般称携带ACK标志的TCP报文段为<strong>确认报文段</strong>。</li>
  <li>PSH 接收方应该尽快将这个报文段送给应用层。</li>
  <li>RST 复位报文段，表示需要重建连接。</li>
  <li>SYN 同步序号，用来发起一个连接。</li>
  <li>
    <p>FIN 发送端完成发送任务，并要求释放TCP连接。</p>
  </li>
  <li><strong>窗口大小</strong> （2字节）</li>
</ul>

<p>该字段指出了现在允许对方发送的数据量，它告诉对方本端的TCP接收缓冲区还能容纳多少数据，对方端以此来控制发送速度。</p>

<ul>
  <li><strong>校验和</strong> （2字节）</li>
</ul>

<p>由发送端填充，接收端对报文段执行校验，范围包括首部和数据。这是一个强制性的字段，以保证TCP传输的可靠性。</p>

<ul>
  <li><strong>紧急指针</strong> （2字节）</li>
</ul>

<p>仅在<strong>标志位</strong>URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。发送方TCP会把紧急数据插到本报文段的最前面。紧急指针指出了紧急数据的末尾在报文段的位置。</p>

<h4 id="生命周期">生命周期</h4>

<p>整个TCP的连接和释放过程如下图所示：</p>

<p><img src="/assets/1111111111111111.png" alt="" /></p>

<h5 id="连接---三次握手">连接 - 三次握手</h5>

<p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>

<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行<code class="highlighter-rouge">connect()</code>时。将触发三次握手。</p>

<ul>
  <li>第一次握手(SYN=1, seq=x):</li>
</ul>

<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>

<p>发送完毕后，客户端进入<code class="highlighter-rouge">SYN_SEND</code>状态。</p>

<ul>
  <li>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</li>
</ul>

<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入<code class="highlighter-rouge">SYN_RCVD</code>状态。</p>

<ul>
  <li>第三次握手(ACK=1，ACKnum=y+1)</li>
</ul>

<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p>

<p>发送完毕后，客户端进入<code class="highlighter-rouge">ESTABLISHED</code>状态，当服务器端接收到这个包时，也进入<code class="highlighter-rouge">ESTABLISHED</code>状态，TCP 握手结束。</p>

<h5 id="断开---四次挥手">断开 - 四次挥手</h5>

<p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行<code class="highlighter-rouge">close()</code>操作即可产生挥手操作。</p>

<ul>
  <li>第一次挥手(FIN=1，seq=x)</li>
</ul>

<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>

<p>发送完毕后，客户端进入<code class="highlighter-rouge">FIN_WAIT_1</code>状态。</p>

<ul>
  <li>第二次挥手(ACK=1，ACKnum=x+1)</li>
</ul>

<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>

<p>发送完毕后，服务器端进入<code class="highlighter-rouge">CLOSE_WAIT</code>状态，客户端接收到这个确认包之后，进入<code class="highlighter-rouge">FIN_WAIT_2</code>状态，等待服务器端关闭连接。</p>

<ul>
  <li>第三次挥手(FIN=1，seq=y)</li>
</ul>

<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p>

<p>发送完毕后，服务器端进入<code class="highlighter-rouge">LAST_ACK</code>状态，等待来自客户端的最后一个ACK。</p>

<ul>
  <li>第四次挥手(ACK=1，ACKnum=y+1)</li>
</ul>

<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入<code class="highlighter-rouge">TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p>

<p>服务器端接收到这个确认包之后，关闭连接，进入<code class="highlighter-rouge">CLOSED</code>状态。</p>

<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<code class="highlighter-rouge">CLOSED</code>状态。</p>


</div>

<div class="pagination">
  
    <a href="/2017-03-02/UDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="left arrow">&#8592;</a>
  
  
    <a href="/2017-02-20/%E7%94%A8-%E6%99%AE%E9%80%9A%E8%AF%9D-%E6%8F%8F%E8%BF%B0%E8%AE%BE%E8%AE%A1%E5%85%AD%E5%8E%9F%E5%88%99" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
      <span>
        &copy; <time datetime="2018-05-30 17:46:50 +0800">2018</time> Gerald. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
      </span>
    </footer>
  </body>
</html>
