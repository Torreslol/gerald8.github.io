---
layout: post
title: "TCP协议简单介绍"
author: "Gerald"
---


#### TCP首部

TCP协议位于传输层，是一种面向连接的、可靠的、基于字节流的通信协议。TCP首部的很多字段都是为了实现这2大特性而设计的。 在一个TCP连接中，仅有两方能进行彼此通信。如果不计任选字段，TCP的首部通常是20字段。

![](/assets/CFC6314E4B2FD039C450821D946E93E2.png)

TCP 的首部包括以下内容：

<!--more-->

* **源端口和目的端口**（4字节）

每个TCP段都包含源端口和目的端口，用于寻找发端和收端应用进程。这2个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。

* **序号**（4字节）

TCP 是面向字节流的，在一个 TCP 连接中传输的字节流中的每个字节都按照顺序编号。序号字段值指的是本报文段所发送的数据的第一个字节的序号。

* **确认号** （4字节）

表示期望收到的下一个报文段的序号的值。在TCP连接中接收方在收到一个报文后需要返回对应的**确认报文**来确认收到**。**

* **数据偏移** （0.5字节）

这个字段实际上是指出了**TCP 报文段的首部长度**，它指出了TCP报文段的数据起始处距离TCP报文的起始处有多远。

* **保留** （0.75字节）

保留为今后使用，目前应置0。

* **标志位** （共六个，0.75字节）

* URG 紧急指针有效，与首部中的紧急指针字段配合使用。
* ACK 确认序号有效，一般称携带ACK标志的TCP报文段为**确认报文段**。
* PSH 接收方应该尽快将这个报文段送给应用层。
* RST 复位报文段，表示需要重建连接。
* SYN 同步序号，用来发起一个连接。
* FIN 发送端完成发送任务，并要求释放TCP连接。

* **窗口大小** （2字节）

该字段指出了现在允许对方发送的数据量，它告诉对方本端的TCP接收缓冲区还能容纳多少数据，对方端以此来控制发送速度。

* **校验和** （2字节）

由发送端填充，接收端对报文段执行校验，范围包括首部和数据。这是一个强制性的字段，以保证TCP传输的可靠性。

* **紧急指针** （2字节）

仅在**标志位**URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。发送方TCP会把紧急数据插到本报文段的最前面。紧急指针指出了紧急数据的末尾在报文段的位置。

#### 生命周期

整个TCP的连接和释放过程如下图所示：

![](/assets/1111111111111111.png)



##### 连接 - 三次握手

所谓三次握手\(Three-way Handshake\)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行`connect()`时。将触发三次握手。

* 第一次握手\(SYN=1, seq=x\):

客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号\(Sequence Number\)字段里。

发送完毕后，客户端进入`SYN_SEND`状态。

* 第二次握手\(SYN=1, ACK=1, seq=y, ACKnum=x+1\):

服务器发回确认包\(ACK\)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号\(Acknowledgement Number\)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入`SYN_RCVD`状态。

* 第三次握手\(ACK=1，ACKnum=y+1\)

客户端再次发送确认包\(ACK\)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1

发送完毕后，客户端进入`ESTABLISHED`状态，当服务器端接收到这个包时，也进入`ESTABLISHED`状态，TCP 握手结束。

##### 断开 - 四次挥手

TCP 的连接的拆除需要发送四个包，因此称为四次挥手\(Four-way handshake\)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行`close()`操作即可产生挥手操作。

* 第一次挥手\(FIN=1，seq=x\)

假设客户端想要关闭连接，客户端发送一个 FIN 标志位为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。

发送完毕后，客户端进入`FIN_WAIT_1`状态。

* 第二次挥手\(ACK=1，ACKnum=x+1\)

服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。

发送完毕后，服务器端进入`CLOSE_WAIT`状态，客户端接收到这个确认包之后，进入`FIN_WAIT_2`状态，等待服务器端关闭连接。

* 第三次挥手\(FIN=1，seq=y\)

服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。

发送完毕后，服务器端进入`LAST_ACK`状态，等待来自客户端的最后一个ACK。

* 第四次挥手\(ACK=1，ACKnum=y+1\)

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入`TIME_WAIT`状态，等待可能出现的要求重传的 ACK 包。

服务器端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。

客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入`CLOSED`状态。
