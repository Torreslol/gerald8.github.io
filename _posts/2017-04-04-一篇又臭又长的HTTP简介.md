---
layout: post
title: "一篇又臭又长的HTTP简介"
author: "wx"
---


### 简介

HTTP协议（**超文本传输协议**）是互联网的基础协议，每天都有数以万计的图片、HTML页面、文本文件、音视频文件和其他资源通过HTTP协议在因特网上传递。

### 主要特点

1.支持客户/服务器模式。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

<!--more-->

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

关于无连接与无状态的理解都是相对的，HTTP1.0之后的持久连接，允许多个请求使用同一个TCP连接，session和cookie也使得HTTP通讯变的有状态。具体的会在下面说到。

### 资源

**媒体类型**

Web服务器会为所有的HTTP对象数据附加一个**MIME**类型，当浏览器从服务器取回一个对象时，会去查看相关的**MIME**类型，看看他是否知道如何处理这个对象。常见的**MIME**类型有几百种，对应到请求头的_Content-Type_字段: 比如：

* HTML格式的文本文档标记为 _text/html_。
* 普通的ASCII文本文档标记为 _text/plain_。
* JPEG格式的图片标记为 _image/jpeg_。
* GIF格式的图片标记为_ image/gif_。

完成的MIME类型列表 参见[传送门](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)。

**URL和URI**

每个Web服务器资源都有一个名字，这个名字被统称为**统一资源标识符**（Uniform Resource Identifier, URI）**。**

**统一资源定位符**（URL）是资源标识符最常见的形式。URL描述了一台特定服务器上某资源的特定位置。

### 事务

一个HTTP事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为HTTP报文的格式化数据块进行的，如图所示：

![](/assets/05.d01z.05.png)

**方法**

HTTP支持几种不同的请求命令，这些命令被称为HTTP方法。每条HTTP请求报文都包含一个方法。常见的HTTP方法：

* **GET **- 从服务器像客户端发送命名资源。
* **PUT** - 将来自客户端的数据存储到一个命名的服务器资源中去。
* **POST **- 将客户端数据发送到一个服务器网关应用程序。
* **DELETE **- 从服务器中删除命名资源。
* **HEAD **- 仅发送命名资源响应中的HTTP首部。

**状态码**

* 1xx消息 - 请求已被服务器接收，继续处理
* 2xx成功——请求已成功被服务器接收、理解、并接受
* 3xx重定向——需要后续操作才能完成这一请求
* 4xx请求错误——请求含有词法错误或者无法被执行
* 5xx服务器错误——服务器在处理某个正确请求时发生错误

**报文**

HTTP的报文分为**请求报文**和**相应报文**两种。
HTTP的这两种报文都由三部分组成：**起始行**、**首部**、**主体**。

如下图：

![](/assets/241034588189239.png)

* 起始行

报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。

* 首部字段

起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。

* 首部

每个HTTP 首部都有一种简单的语法：名字后面跟着冒号（：），然后跟上可选的空格，再跟上字段值，最后是一个CRLF。（或者换行符）。

* 主体

空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给Web服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。

### 连接

HTTP连接方式进化史

* **HTTP/0.9 短连接**

每个HTTP请求都要经历一次DNS解析、三次握手、传输和四次挥手。反复创建和断开TCP连接的开销巨大。

* **HTTP/1.0 持久连接**

人们认识到短连接的弊端，提出了持久连接的概念，在HTTP/1.0中得到了初步的支持。持久连接，即一个TCP连接服务多次请求：客户端在请求header中携带Connection: Keep-Alive，即是在向服务端请求持久连接。如果服务端接受持久连接，则会在响应header中同样携带Connection: Keep-Alive，这样客户端便会继续使用同一个TCP连接发送接下来的若干请求。（Keep-Alive的默认参数是\[timout=5, max=100\]，即一个TCP连接可以服务至多5秒内的100次请求）当服务端主动切断一个持久连接时（或服务端不支持持久连接），则会在header中携带Connection: Close，要求客户端停止使用这一连接。

对比**短连接**如图：

![](/assets/v2-755722cfb502cebbe639bc311270eb47_r.jpg)

* **HTTP/1.1 管道**

HTTP 1.1开始，持久连接成了默认连接方式。即使请求header中没有携带Connection: Keep-Alive，传输也会默认以持久连接的方式进行。同时，持久连接的弊端被提出 —— HOLB（Head of Line Blocking）即持久连接下一个连接中的请求仍然是串行的，如果某个请求出现网络阻塞等问题，会导致同一条连接上的后续请求被阻塞。所以HTTP/1.1中提出了pipelining概念，即客户端可以在一个请求发送完成后不等待响应便直接发起第二个请求，服务端在返回响应时会按请求到达的顺序依次返回，这样就极大地降低了延迟。如图：

![](/assets/pipelining.jpg)

然而pipelining并没有彻底解决HOLB，为了让同一个连接中的多个响应能够和多个请求匹配上，响应仍然是按请求的顺序串行返回的。所以pipelining并没有被广泛接受，几乎所有代理服务都不支持pipelining，部分浏览器不支持pipelining，支持的大部分也会将其默认关闭。

* **SPDY/HTTP 2.0 多路复用**

随着现代网页的不断丰富， HTTP/1.1 协议的性能也逐渐吃不消，因此2012年google如一声惊雷提出了SPDY的方案，实际上，HTTP/2.0 也是以 SPDY 作为原型进行开发的。SPDY提出了多路复用\(multiplexing\)。多路复用通过多个请求stream共享一个tcp连接的方式，解决了http1.x holb（head of line blocking）的问题，降低了延迟同时提高了带宽的利用率。如图：

![](/assets/http.png)

multiplexing技术能够让多个请求和响应的传输完全混杂在一起进行，通过streamId来互相区别。这彻底解决了holb问题，同时还允许给每个请求设置优先级，服务端会先响应优先级高的请求。

### 代理

HTTP 代理存在两种形式，分别简单介绍如下：

* **普通代理**

HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。如下图:

![](https://st.imququ.com/i/webp/static/uploads/2015/11/web_proxy.png.webp)

这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。

* **隧道代理**

HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。下图直观地展示了上述行为:

![](https://st.imququ.com/i/webp/static/uploads/2015/11/web_tunnel.png.webp)

假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。

### 认证

* **基本认证**

在HTTP中，基本认证（Basic authentication）是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。因为Base64可以轻松被解码，所以基本认证常用在安全的连接上，如公司内部系统或配合TLS协议使用。

我们来看一个典型的应用场景，下面是一个使用基本认证的HTTP客户端和服务器的对话：

1. 客户端请求一个需要身份认证的页面，但是没有提供用户名和口令。

2. 服务端响应一个401应答码，并提供一个认证域。

3. 接到应答后，客户端显示该认证域（通常是所访问的计算机或系统的描述）给用户并提示输入用户名和口令。此时用户可以选择确定或取消。

4. 用户输入了用户名和口令后，客户端软件会在原先的请求上增加认证消息头（值是base64encode\(username+":"+password\)），然后重新发送再次尝试

5. 服务器接受了该认证屏幕并返回了页面。如果用户凭据非法或无效，服务器可能再次返回401应答码，客户端可以再次提示用户输入口令。

注意:客户端有可能不需要用户交互，在第一次请求中就发送认证消息头。

来看一下上面例子的HTTP报文信息:

**客户端请求\(没有认证信息\)**

```
GET /private/index.html HTTP/1.0
Host: localhost
```

**服务端应答**

```
HTTP/1.0 401 Authorization Required
Server: HTTPd/1.0
Date: Sat, 27 Nov 2004 10:18:15 GMT
WWW-Authenticate: Basic realm="Secure Area"
Content-Type: text/html
Content-Length: 311

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML>
<HEAD>
<TITLE>Error</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
</HEAD>
<BODY><H1>401 Unauthorized.</H1></BODY>
</HTML>
```

**客户端再请求**

```
GET /private/index.html HTTP/1.0
Host: localhost
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
```

**服务端成功应答**

```
HTTP/1.0 200 OK
Server: HTTPd/1.0
Date: Sat, 27 Nov 2004 10:19:07 GMT
Content-Type: text/html
Content-Length: 10476
```

* **摘要认证**

摘要认证\(Digest Authentication\)与基础认证的工作原理很相似，摘要认证则针对Basic认证存在的诸多问题而进行的改良方案，试图修复Basci认证的严重缺陷：

1. 通过传递用户名，密码等计算出来的摘要来解决明文方式在网络上发送密码的问题。

2. 通过服务产生随机数nonce的方式可以防止恶意用户捕获并重放认证的握手过程。

3. 通过客户端产生随机数cnonce的方式，支持客户端对服务器的认证。

4. 通过对内容也加入摘要计算的方式，可以有选择的防止对报文内容的篡改。

但是，摘要认证并不是最安全的协议，也无法满足安全HTTP事务的很多需求，对这些需求来说，可能使用HTTPS方式更为合适。

一个单向摘要认证的握手过程如下：

**客户端请求（无认证）**

```
GET /dir/index.html HTTP/1.0
Host: localhost
```

**服务器响应**

```
HTTP/1.0 401 Unauthorized
Server: HTTPd/0.9
Date: Sun, 10 Apr 2005 20:26:47 GMT
WWW-Authenticate: Digest realm="testrealm@host.com",
qop="auth,auth-int",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
Content-Type: text/html
Content-Length: 311

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML>
<HEAD>
<TITLE>Error</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
</HEAD>
<BODY><H1>401 Unauthorized.</H1></BODY>
</HTML>
```

**客户端再请求 \(用户名 "Mufasa", 密码 "Circle Of Life"\)**

```
GET /dir/index.html HTTP/1.0
Host: localhost
Authorization: Digest username="Mufasa",
realm="testrealm@host.com",
nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
uri="/dir/index.html",
qop=auth,
nc=00000001,
cnonce="0a4f113b",
response="6629fae49393a05397450978507c4ef1",
opaque="5ccc069c403ebaf9f0171e9517f40e41"
```

**服务器成功响应**

```
HTTP/1.0 200 OK
Server: HTTPd/0.9
Date: Sun, 10 Apr 2005 20:27:03 GMT
Content-Type: text/html
Content-Length: 7984
```

客户端再请求 的 response 值由三步计算而成。当多个数值合并的时候，使用冒号作为分割符。

对用户名、认证域\(realm\)以及密码的合并值计算 MD5 哈希值，结果称为 HA1。
对HTTP方法以及URI的摘要的合并值计算 MD5 哈希值，例如，"GET" 和 "/dir/index.html"，结果称为 HA2。
对 HA1、服务器密码随机数\(nonce\)、请求计数\(nc\)、客户端密码随机数\(cnonce\)、保护质量\(qop\)以及 HA2 的合并值计算 MD5 哈希值。结果即为客户端提供的 response 值。
因为服务器拥有与客户端同样的信息，因此服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。

**随机数的生成**

RFC2617建议采用这个假想的随机数公式：

```
nonce = BASE64(time-stamp MD5(time-stamp “:” ETag “:” private-key))
```

其中:

time-stamp是服务器产生的时间戳或者其他不会重复的序列号，ETag是与所请求实体有关的HTTP ETag首部的值，priviate-key是只有服务器知道的数据。这样，服务器就可以收到客户端的认证首部之后重新计算散列部分，如果结果与那个首部的随机数不符，或者是时间戳的值不够新，就可以拒绝请求，服务器可以通过这种方式来限制随机数的有效持续时间。

### HTTP2.0 新特性

**二进制分帧**

HTTP 2.0最大的特点： 不会改动HTTP 的语义，HTTP 方法、状态码、URI 及首部字段，等等这些核心概念上一如往常，却能致力于突破上一代标准的性能限制，改进传输性能，实现低延迟和高吞吐量。而之所以叫2.0，是在于新增的二进制分帧层。
既然又要保证HTTP的各种动词，方法，首部都不受影响，那就需要在应用层(HTTP2.0)和传输层(TCP or UDP)之间增加一个二进制分帧层。
在二进制分帧层上， HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。
HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。

![](/assets/binary.png)

**首部压缩**

如下图所示： HTTP 2.0在客户端和服务端使用首部表来跟踪和存储之间发送的键-值对，对相同请求而言不需要再次发送请求和相应发送，通信期间几乎不会改变的通用键值,如user-Agent和content-Type值发送一次，相当于做了一层缓存。

如果请求不包含首部，如：对同一资源的轮询请求，那首部开销为零字节
如果首部发生变化，那只需发送变化的数据在Headers帧里面，新增或修改的首部帧会被追加到首部表

![](/assets/header.png)

**多路复用**

在**连接**章节已经提到，多路复用允许通过单一的HTTP 2.0连接发起多重的请求-相应消息
这意味着HTTP 2.0的通信都在一个连接上完成了，这个连接可以承载任意数量的双向数据流。

**请求优先级**

每个HTTP 2.0流里面有个优先值，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，高优先级的流都应该优先发送，但又不会绝对的。绝对地遵守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。

**服务端推送**

HTTP 2.0中，当用户的浏览器和服务器在建立连接后，服务器主动将一些资源推送给浏览器并缓存起来，这样当浏览器接下来请求这些资源时就直接从缓存中读取，不会在从服务器上拉了，提升了速率。
